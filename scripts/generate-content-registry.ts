import * as fs from 'fs';
import * as path from 'path';

type ContentSection = 'blog' | 'portfolio' | 'projects' | 'libraries';

interface ContentEntry {
  slug: string;
  importPath: string;
}

/**
 * ì½˜í…ì¸  ë””ë ‰í† ë¦¬ë¥¼ ìŠ¤ìº”í•˜ì—¬ ëª¨ë“  .tsx íŒŒì¼ ì°¾ê¸°
 */
function discoverContent(section: ContentSection): ContentEntry[] {
  const viewsDir = path.join(process.cwd(), 'src', 'views', section);
  const entries: ContentEntry[] = [];

  if (!fs.existsSync(viewsDir)) {
    console.warn(`âš ï¸  Warning: Views directory not found: ${viewsDir}`);
    return entries;
  }

  function scan(dir: string, relativePath: string = '') {
    const items = fs.readdirSync(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = path.join(dir, item.name);
      const itemRelativePath = relativePath
        ? path.join(relativePath, item.name)
        : item.name;

      if (item.isDirectory()) {
        // í´ë” ë‚´ë¶€ ìŠ¤ìº”
        scan(fullPath, itemRelativePath);
      } else if (item.name === 'index.tsx') {
        // {slug}/index.tsx íŒ¨í„´ (ê¸°ë³¸ ë°©ì‹)
        const slug = relativePath || item.name.replace('.tsx', '');
        entries.push({
          slug,
          importPath: `@/views/${section}/${slug}`,
        });
      } else if (item.name.endsWith('.tsx') && !relativePath) {
        // ë£¨íŠ¸ ë ˆë²¨ì˜ ë‹¨ì¼ .tsx íŒŒì¼ (ì§€ì›)
        const slug = item.name.replace('.tsx', '');
        entries.push({
          slug,
          importPath: `@/views/${section}/${slug}`,
        });
      }
    }
  }

  scan(viewsDir);
  return entries;
}

/**
 * ì„¹ì…˜ëª…ì„ PascalCaseë¡œ ë³€í™˜
 */
function toPascalCase(section: ContentSection): string {
  const map: Record<ContentSection, string> = {
    blog: 'Blog',
    portfolio: 'Portfolio',
    projects: 'Project',
    libraries: 'Library',
  };
  return map[section];
}

/**
 * ì¹´í…Œê³ ë¦¬ íƒ€ì…ëª… ìƒì„±
 */
function getCategoryType(section: ContentSection): string {
  const map: Record<ContentSection, string> = {
    blog: 'BlogCategory',
    portfolio: 'PortfolioCategory',
    projects: 'ProjectCategory',
    libraries: 'LibraryCategory',
  };
  return map[section];
}

/**
 * ì—”í‹°í‹° í´ë”ëª…ìœ¼ë¡œ ë³€í™˜ (viewsëŠ” ë³µìˆ˜í˜•, entitiesëŠ” ë‹¨ìˆ˜í˜•)
 */
function getEntityFolderName(section: ContentSection): string {
  const map: Record<ContentSection, string> = {
    blog: 'blog',
    portfolio: 'portfolio',
    projects: 'project',
    libraries: 'library',
  };
  return map[section];
}

/**
 * ë ˆì§€ìŠ¤íŠ¸ë¦¬ íŒŒì¼ ìƒì„±
 */
function generateRegistry(section: ContentSection) {
  const entries = discoverContent(section);

  if (entries.length === 0) {
    console.warn(
      `âš ï¸  Warning: No content found for section: ${section}`
    );
    return;
  }

  const pascalSection = toPascalCase(section);
  const categoryType = getCategoryType(section);
  const typeName = pascalSection;

  // Import ë¬¸ ìƒì„±
  const imports = entries
    .map(
      (entry, idx) =>
        `import Content${idx}, { metadata as meta${idx} } from '${entry.importPath}';`
    )
    .join('\n');

  // ë°°ì—´ í•­ëª© ìƒì„±
  const arrayItems = entries
    .map(
      (entry, idx) => `  {
    slug: '${entry.slug}',
    ...meta${idx},
    Component: Content${idx},
  }`
    )
    .join(',\n');

  // ì¹´í…Œê³ ë¦¬ í•„í„° í•¨ìˆ˜ëª…
  const filterFunctionName = `get${pascalSection}ListByCategory`;
  const registryName = `${section}Registry`;

  // TypeScript ì½”ë“œ ìƒì„±
  const code = `// THIS FILE IS AUTO-GENERATED - DO NOT EDIT MANUALLY
// Generated by scripts/generate-content-registry.ts

import type { ${typeName} } from './types';
import type { ${categoryType} } from '@/core/types/metadata';

${imports}

export const ${registryName}: ${typeName}[] = [
${arrayItems}
];

/**
 * ì¹´í…Œê³ ë¦¬ë¡œ ì½˜í…ì¸  í•„í„°ë§
 */
export function ${filterFunctionName}(category: ${categoryType}): ${typeName}[] {
  return ${registryName}.filter(item => item.category.includes(category));
}
`;

  // ì¶œë ¥ ê²½ë¡œ ì„¤ì •
  const entityFolder = getEntityFolderName(section);
  const outputPath = path.join(
    process.cwd(),
    'src',
    'entities',
    entityFolder,
    'registry.generated.ts'
  );

  // íŒŒì¼ ì“°ê¸°
  fs.writeFileSync(outputPath, code, 'utf-8');
  console.log(
    `âœ… Generated ${section} registry: ${entries.length} ${entries.length === 1 ? 'entry' : 'entries'}`
  );
}

/**
 * ëª¨ë“  ì„¹ì…˜ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒì„±
 */
function generateAllRegistries() {
  console.log('ğŸ”§ Generating content registries...\n');

  const sections: ContentSection[] = [
    'blog',
    'portfolio',
    'projects',
    'libraries',
  ];

  sections.forEach(section => {
    try {
      generateRegistry(section);
    } catch (error) {
      console.error(`âŒ Error generating registry for ${section}:`, error);
      process.exit(1);
    }
  });

  console.log('\nâœ¨ All registries generated successfully!');
}

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
generateAllRegistries();
